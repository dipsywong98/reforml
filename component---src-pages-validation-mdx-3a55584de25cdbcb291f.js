(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{EL9F:function(e,a,n){"use strict";n.r(a),n.d(a,"_frontmatter",(function(){return r})),n.d(a,"default",(function(){return o}));n("W1QL"),n("K/PF"),n("t91x"),n("75LO"),n("5hJT"),n("mXGw");var t=n("/FXl");var r={},l={_frontmatter:r};function o(e){var a=e.components,n=function(e,a){if(null==e)return{};var n,t,r={},l=Object.keys(e);for(t=0;t<l.length;t++)n=l[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,["components"]);return Object(t.b)("wrapper",Object.assign({},l,n,{components:a,mdxType:"MDXLayout"}),Object(t.b)("h1",{id:"validation"},"Validation"),Object(t.b)("p",null,"Reforml provides way to utilize ",Object(t.b)("a",Object.assign({parentName:"p"},{href:"//wiki.developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation"}),"HTML constraints")," and any custom validators including validators from other libraries.\nYou can also customize the error message"),Object(t.b)("h2",{id:"html-constraints"},"HTML Constraints"),Object(t.b)("p",null,"You can directly supply ",Object(t.b)("a",Object.assign({parentName:"p"},{href:"//wiki.developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation"}),"HTML constraints")," in field definition, if you are using controlled form,\nyou need to manually called ",Object(t.b)("inlineCode",{parentName:"p"},"validate")," in ",Object(t.b)("inlineCode",{parentName:"p"},"onChange")," handler since HTML constraints are only validated in uncontrolled form"),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx",metastring:"live=true",live:"true"}),"() => {\n  const [value, setValue] = useState({})\n  const [hasError, setHasError] = useState(false)\n  const handleChange = (newValue, {validate}) => {\n    const error = validate()\n    setHasError(!!error)\n    setValue(newValue)\n  }\n  const fields = useMemo(() => jsyaml.load(`\n  myText:\n    type: text\n    label: Input some value\n    helperText: a required field with minLength\n    required: true\n    minLength: 6\n  myNumber:\n    type: number\n    label: Number\n    required: true\n    min: 0\n    max: 10\n    step: 2\n  `), [])\n  return (\n    <div>\n      <BaseForm fields={fields} value={value} onChange={handleChange}/>\n      value:\n      <pre>{JSON.stringify(value, null, 2)}</pre>\n      <p>{hasError ? 'ERROR' : 'OK'}</p>\n    </div>\n  )\n}\n")),Object(t.b)("h2",{id:"custom-validation"},"Custom Validation"),Object(t.b)("p",null,'By supplying a validatorDictionary to ReformlProvider,\nBasicForm inside it can use yaml with field containing a validation property.\nThe validation property is a list of "validation rule name" or "rule name to params array map" or "rule name to single param"\nYou can notice the mapping of params in YAML definition to validator function implementation'),Object(t.b)("p",null,"validatorDictionary is a rule name to validator map,\na validator is a function that accept first parameter as the field value,\nrest parameter from field validation settings from the yaml,\nand return a boolean to determine whether the value passes the validation."),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx",metastring:"live=true",live:"true"}),"() => {\n  const [value, setValue] = useState({})\n  const [hasError, setHasError] = useState(false)\n  const handleChange = (newValue, {validate}) => {\n    const error = validate()\n    setHasError(!!error)\n    setValue(newValue)\n  }\n  const fields = useMemo(() => jsyaml.load(`\n  myText:\n    type: text\n    label: Must be Foo\n    required: true\n    validate:\n      - isFoo\n      - isEqual: Foo\n      - isLengthBetween:\n        - 2\n        - 4\n  `), [])\n  return (\n    <ReformlProvider validatorDictionary={{\n    isFoo: (value) => value === 'Foo',\n    isEqual: (value, compare) => value === compare,\n    isLengthBetween: (value, a, b) => value.length >= a && value.length <= b\n    }}>\n      <BaseForm fields={fields} value={value} onChange={handleChange}/>\n      value:\n      <pre>{JSON.stringify(value, null, 2)}</pre>\n      <p>{hasError ? 'ERROR' : 'OK'}</p>\n    </ReformlProvider>\n  )\n}\n")),Object(t.b)("p",null,"In field definition you can even implement a validator function directly"),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx",metastring:"live=true",live:"true"}),"() => {\n  const [value, setValue] = useState({})\n  const [hasError, setHasError] = useState(false)\n  const handleChange = (newValue, {validate}) => {\n    const error = validate()\n    setHasError(!!error)\n    setValue(newValue)\n  }\n  const fields = useMemo(() => {\n  const fields = jsyaml.load(`\n  myText:\n    type: text\n    label: Must be Foo\n    required: true\n  `)\n  fields.myText.validate = [{\n    isFoo: (value) => value === 'Foo'\n  }]\n  return fields\n  }, [])\n  return (\n    <div>\n      <BaseForm fields={fields} value={value} onChange={handleChange}/>\n      value:\n      <pre>{JSON.stringify(value, null, 2)}</pre>\n      <p>{hasError ? 'ERROR' : 'OK'}</p>\n    </div>\n  )\n}\n")),Object(t.b)("h2",{id:"validatorjs-integration"},"validator.js integration"),Object(t.b)("p",null,"The Validators used in reforml shares the same interface as validator.js, so you can use them directly"),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-bash"}),"npm i validator\n")),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"import validators from 'validator'\n\nconst myValidators = {\n  isFoo: (value) => value === 'Foo',\n  isEqual: (value, compare) => value === compare,\n  isLengthBetween: (value, a, b) => value.length >= a && value.length <= b\n}\n\n() => {\nreturn <ReformlProvider validatorDictionary={{\n  ...validators,\n  ...myValidators\n  }}>\n    {/* BaseForm here */}\n  </Reforml>\n}\n")),Object(t.b)("h2",{id:"customize-the-error-message"},"Customize the error message"),Object(t.b)("p",null,"ValidateErrorFormatter has the following signature"),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"export type ValidateErrorFormatter = <T>(value: T, ruleName: string, params: never[]) => string\n")),Object(t.b)("p",null,"value is the value supplied in the form, ruleName is the name of validation, params is the array of param supply to the validator"),Object(t.b)("p",null,"and you can supply the formatter to ReformlProvider"),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"const validateErrorFormatter = (_, ruleName, params) => {\n  return ruleName + (params.length === 0 ? '' : ':' + params.join(','))\n}\n() => {\n  return <ReformlProvider validateErrorFormatter={validateErrorFormatter}>\n      {/* BaseForm here */}\n    </ReformlProvider>\n  }\n")))}o.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-validation-mdx-3a55584de25cdbcb291f.js.map